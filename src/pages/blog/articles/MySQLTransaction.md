---
layout: "@layouts/ArticleLayout.astro"
title: MySQL事务
description: 主要摘抄至出版书籍
date: 2023-02-20 10:00:00
tags:
  - MySQL
  - Transaction
  - 事务
---

## 事务

### 1.什么是事务

事务是对数据库中一些操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。

### 2.事务四大特性(ACID)

**原子性-Atomicity：**

指事务包含的操作要么全部成功，要么全部失败回滚，因此事务的操作如果操作成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

**一致性-Consistency：**

事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不能A扣了钱，B却没收到。

**隔离性-Isolation：**

隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。

**持久性-Durability：**

持久性是指一个事务一旦被提交了，那么对数据库总的数据的改变就是永久性的，即便在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

### 3.事务的并发？事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别？

理论上来说，事务应该彼此完全隔离，以避免并发事务所导致的问题。然后，那样会对性能产生机打的影响，因为事务必须按顺序运行，在实际开发中，为了提升性能，事务会以较低的隔离级别运行，事务的隔离级别可以通过隔离事务属性指定。

#### 事务并发带来的问题

1. **脏读**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据就是脏数据
2. **不可重复读**：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据做了更新并提交，导致事务A多次读取同一数据时，结果因为事务B先后两次读取到的数据结果会不一致
3. **幻读**：幻读解决了不可重复读，保证了同一个事务里，查询的结果都是事务开始的状态（一致性）

**小结**：不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表。

#### 事务的隔离级别

**读未提交：**另一个事务修改了数据，但尚未提交，而本事务中的 SELECT会读到这些未提交的数据。

**不可重复读：**事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据做了更新并提交，导致事务A多次读取同一数据时，结果因为事务B先后两次读取到的数据结果会不一致。

**可重复读：**在同一个事务里，SELECT的结果是事务开始时间点的状态，因此同样的SELECT操作读到的结果会是一致的。但是会有幻读现象。

**串行化：**最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样。

**特别注意：**

MySQL默认的事务隔离级别为 repeatable-read(可重复读)

MySQL支持4种隔离级别

事务的隔离级别要得到底层数据库引擎的支持，而不是应用程序或者框架的支持。

Orale支持的2种隔离级别：read_commited，serializable

MySQL中默认的事务隔离级别并不会锁住读取到的行

| 事务隔离级别 | 操作 |
| ------ | ----------- |
| 未提交读 | 写数据只会锁住相应的行 |
| 可重复读 | 写数据会锁住整张表   |
| 串行化 | 读写数据都会锁住整张表 |

### 4.事务传播行为

1. PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。

2. PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。

3. PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。

4. PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。

5. PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

6. PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。

7. PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。

### 5.嵌套事务

什么是嵌套事务？

嵌套是指子事务套在父事务中执行，子事务是父事务的一部分，在进入事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。

如果子事务回滚，会发生什么？

父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。

如果父事务回滚，会发生什么？

父事务回滚，子事务也会跟着回滚！因为父事务结束之前，子事务是不会提交的。

事务的提交，是什么情况？

子事务先提交，父事务再提交，子事务是父事务的一部分， 由父事务统一提交。