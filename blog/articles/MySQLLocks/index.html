<!DOCTYPE html><html lang="en" class="astro-H24362AN">
  <head>
    <title>MySQL锁</title>
<meta charset="UTF-8">

<meta name="author" content="gwalnut">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="keywords" content="Blog,Astro">
<meta name="description" content="主要摘抄至出版书籍">
<meta name="category" content="Blog">
<link rel="canonical" href="https://jonascaptain.github.io/blog/articles/MySQLLocks/">
<meta name="generator" content="Astro v1.1.1">

<!-- Robot.txt -->
<meta name="robots" content="index,follow">
<meta name="Googlebot" content="index,follow">
<meta name="AdsBot-Google" content="index,follow">

<!-- FaceBook Meta data -->
<meta property="og:site_name" content="https://jonascaptain.github.io/blog/articles/MySQLLocks/">
<meta property="og:title" content="MySQL锁">
<meta property="og:description" content="主要摘抄至出版书籍">
<meta property="og:type" content="website">
<meta property="og:url" content="https://jonascaptain.github.io/blog/articles/MySQLLocks/">

<!-- Twitter Meta data -->
<meta name="twitter:card" content="My personal blog">
<meta name="twitter:url" content="https://jonascaptain.github.io/blog/articles/MySQLLocks/">
<meta name="twitter:title" content="MySQL锁">
<meta name="twitter:site" content="https://jonascaptain.github.io/blog/articles/MySQLLocks/">
<meta name="application-name" content="MySQL锁">
<meta name="twitter:description" content="主要摘抄至出版书籍">

<meta name="apple-mobile-web-app-title" content="MySQL锁">
<meta name="apple-touch-icon" content="/favicon.ico">
<meta name="summary" content="My personal blog">

<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

<script>
  if (localStorage.theme === 'night' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
    document.querySelector('html').setAttribute('data-theme', 'night');
  } else {
    document.querySelector('html').setAttribute('data-theme', 'cmyk');
  }
</script>
  <link rel="stylesheet" href="/assets/50c6c343.ed30341b.css" />
<link rel="stylesheet" href="/assets/d5e0e75b.7bb9d23f.css" />
<link rel="stylesheet" href="/assets/5b4135e6.e480e920.css" /><script type="module" src="/hoisted.b525123c.js"></script></head>

  <body class="astro-H24362AN">
    <a href="#main" class="absolute bg-info text-info-content px-6 py-2 rounded-br-md translate-x-[-100%] focus-within:translate-x-0 transition-all astro-H24362AN">Skip navigation</a>
    <header class="container mx-auto flex items-center justify-between mb-16 astro-H24362AN">
      <div class="p-4 astro-H24362AN">
        <!-- Logo -->
        <svg width="84" height="37" viewBox="0 0 84 37" fill="none" xmlns="http://www.w3.org/2000/svg" class="astro-H24362AN">
          <path d="M26.5625 23.2266C26.5625 25.1953 26.2266 26.9922 25.5547 28.6172C24.8828 30.2422 23.9688 31.6406 22.8125 32.8125C21.6562 33.9688 20.2969 34.8672 18.7344 35.5078C17.1875 36.1484 15.5234 36.4688 13.7422 36.4688C11.9766 36.4688 10.3125 36.1406 8.75 35.4844C7.20312 34.8281 5.84375 33.9141 4.67188 32.7422C3.51562 31.5703 2.60156 30.1797 1.92969 28.5703C1.25781 26.9453 0.921875 25.1641 0.921875 23.2266V0.914062H7.34375V12.6328C7.6875 12.1953 8.10156 11.8047 8.58594 11.4609C9.08594 11.1172 9.61719 10.8359 10.1797 10.6172C10.7578 10.3984 11.3516 10.2344 11.9609 10.125C12.5703 10 13.1641 9.9375 13.7422 9.9375C15.5234 9.9375 17.1875 10.2734 18.7344 10.9453C20.2969 11.6016 21.6562 12.5234 22.8125 13.7109C23.9688 14.8984 24.8828 16.3047 25.5547 17.9297C26.2266 19.5391 26.5625 21.3047 26.5625 23.2266ZM20.1172 23.2266C20.1172 22.2578 19.9453 21.3594 19.6016 20.5312C19.2734 19.6875 18.8203 18.9609 18.2422 18.3516C17.6641 17.7422 16.9844 17.2656 16.2031 16.9219C15.4375 16.5781 14.6172 16.4062 13.7422 16.4062C12.8672 16.4062 12.0391 16.6016 11.2578 16.9922C10.4922 17.3672 9.82031 17.875 9.24219 18.5156C8.66406 19.1406 8.21094 19.8672 7.88281 20.6953C7.55469 21.5078 7.39062 22.3516 7.39062 23.2266C7.39062 24.1953 7.55469 25.0938 7.88281 25.9219C8.21094 26.75 8.66406 27.4688 9.24219 28.0781C9.82031 28.6875 10.4922 29.1719 11.2578 29.5312C12.0391 29.875 12.8672 30.0469 13.7422 30.0469C14.6172 30.0469 15.4375 29.875 16.2031 29.5312C16.9844 29.1719 17.6641 28.6875 18.2422 28.0781C18.8203 27.4688 19.2734 26.75 19.6016 25.9219C19.9453 25.0938 20.1172 24.1953 20.1172 23.2266ZM54.3828 23.2266C54.3828 25.1016 54.0469 26.8516 53.375 28.4766C52.7031 30.0859 51.7891 31.4844 50.6328 32.6719C49.4766 33.8438 48.1172 34.7734 46.5547 35.4609C45.0078 36.1328 43.3438 36.4688 41.5625 36.4688C39.7969 36.4688 38.1328 36.1328 36.5703 35.4609C35.0234 34.7734 33.6641 33.8438 32.4922 32.6719C31.3359 31.4844 30.4219 30.0859 29.75 28.4766C29.0781 26.8516 28.7422 25.1016 28.7422 23.2266C28.7422 21.3203 29.0781 19.5547 29.75 17.9297C30.4219 16.3047 31.3359 14.9062 32.4922 13.7344C33.6641 12.5469 35.0234 11.6172 36.5703 10.9453C38.1328 10.2734 39.7969 9.9375 41.5625 9.9375C43.3438 9.9375 45.0078 10.2578 46.5547 10.8984C48.1172 11.5234 49.4766 12.4219 50.6328 13.5938C51.7891 14.75 52.7031 16.1484 53.375 17.7891C54.0469 19.4141 54.3828 21.2266 54.3828 23.2266ZM47.9375 23.2266C47.9375 22.1953 47.7656 21.2656 47.4219 20.4375C47.0938 19.5938 46.6406 18.875 46.0625 18.2812C45.4844 17.6719 44.8047 17.2109 44.0234 16.8984C43.2578 16.5703 42.4375 16.4062 41.5625 16.4062C40.6875 16.4062 39.8594 16.5703 39.0781 16.8984C38.3125 17.2109 37.6406 17.6719 37.0625 18.2812C36.5 18.875 36.0547 19.5938 35.7266 20.4375C35.3984 21.2656 35.2344 22.1953 35.2344 23.2266C35.2344 24.1953 35.3984 25.0938 35.7266 25.9219C36.0547 26.75 36.5 27.4688 37.0625 28.0781C37.6406 28.6875 38.3125 29.1719 39.0781 29.5312C39.8594 29.875 40.6875 30.0469 41.5625 30.0469C42.4375 30.0469 43.2578 29.8828 44.0234 29.5547C44.8047 29.2266 45.4844 28.7656 46.0625 28.1719C46.6406 27.5781 47.0938 26.8594 47.4219 26.0156C47.7656 25.1719 47.9375 24.2422 47.9375 23.2266ZM83.0469 23.2266C83.0469 25.1953 82.7109 26.9922 82.0391 28.6172C81.3672 30.2422 80.4531 31.6406 79.2969 32.8125C78.1406 33.9688 76.7812 34.8672 75.2188 35.5078C73.6719 36.1484 72.0078 36.4688 70.2266 36.4688C68.4609 36.4688 66.7969 36.1406 65.2344 35.4844C63.6875 34.8281 62.3281 33.9141 61.1562 32.7422C60 31.5703 59.0859 30.1797 58.4141 28.5703C57.7422 26.9453 57.4062 25.1641 57.4062 23.2266V0.914062H63.8281V12.6328C64.1719 12.1953 64.5859 11.8047 65.0703 11.4609C65.5703 11.1172 66.1016 10.8359 66.6641 10.6172C67.2422 10.3984 67.8359 10.2344 68.4453 10.125C69.0547 10 69.6484 9.9375 70.2266 9.9375C72.0078 9.9375 73.6719 10.2734 75.2188 10.9453C76.7812 11.6016 78.1406 12.5234 79.2969 13.7109C80.4531 14.8984 81.3672 16.3047 82.0391 17.9297C82.7109 19.5391 83.0469 21.3047 83.0469 23.2266ZM76.6016 23.2266C76.6016 22.2578 76.4297 21.3594 76.0859 20.5312C75.7578 19.6875 75.3047 18.9609 74.7266 18.3516C74.1484 17.7422 73.4688 17.2656 72.6875 16.9219C71.9219 16.5781 71.1016 16.4062 70.2266 16.4062C69.3516 16.4062 68.5234 16.6016 67.7422 16.9922C66.9766 17.3672 66.3047 17.875 65.7266 18.5156C65.1484 19.1406 64.6953 19.8672 64.3672 20.6953C64.0391 21.5078 63.875 22.3516 63.875 23.2266C63.875 24.1953 64.0391 25.0938 64.3672 25.9219C64.6953 26.75 65.1484 27.4688 65.7266 28.0781C66.3047 28.6875 66.9766 29.1719 67.7422 29.5312C68.5234 29.875 69.3516 30.0469 70.2266 30.0469C71.1016 30.0469 71.9219 29.875 72.6875 29.5312C73.4688 29.1719 74.1484 28.6875 74.7266 28.0781C75.3047 27.4688 75.7578 26.75 76.0859 25.9219C76.4297 25.0938 76.6016 24.1953 76.6016 23.2266Z" fill="#FF0000" class="astro-H24362AN"></path>
        </svg>
      </div>

      <label aria-label="Hamburger Menu" id="nav-toggle" class="btn btn-circle swap swap-rotate fixed z-[999] top-4 right-4 hidden astro-H24362AN" aria-controls="primary-nav" aria-expanded="false">
        <input type="checkbox" class="astro-H24362AN">
        <!-- hamburger icon -->
        <svg class="swap-off fill-current astro-H24362AN" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512">
          <path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z" class="astro-H24362AN"></path>
        </svg>
        <!-- close icon -->
        <svg class="swap-on fill-current astro-H24362AN" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512">
          <polygon points="400 145.49 366.51 112 256 222.51 145.49 112 112 145.49 222.51 256 112 366.51 145.49 400 256 289.49 366.51 400 400 366.51 289.49 256 400 145.49" class="astro-H24362AN"></polygon>
        </svg>
      </label>

      <nav class="mr-6 astro-H24362AN">
        <ul id="primary-nav" class="flex grow gap-8 items-center justify-center z-[100] astro-H24362AN" data-visible="false">
          <li class="after:block after:mx-auto after:h-[0.15em] after:bottom-0 after:w-0 after:bg-green-700 dark:after:bg-amber-400 after:transition-[all_ease_in_out_300ms] after:mt-1 hover:after:w-full astro-6PA5N7LT">
  <a href="/" class="flex hover:text-black dark:hover:text-white p-1 astro-6PA5N7LT">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" /></svg>
    <span class="pl-2 pointer-events-none astro-6PA5N7LT">Home</span>
  </a>
</li><li class="after:block after:mx-auto after:h-[0.15em] after:bottom-0 after:w-0 after:bg-green-700 dark:after:bg-amber-400 after:transition-[all_ease_in_out_300ms] after:mt-1 hover:after:w-full astro-6PA5N7LT">
  <a href="/blog/" class="flex hover:text-black dark:hover:text-white p-1 astro-6PA5N7LT">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" /></svg>
    <span class="pl-2 pointer-events-none astro-6PA5N7LT">Blog</span>
  </a>
</li><li class="after:block after:mx-auto after:h-[0.15em] after:bottom-0 after:w-0 after:bg-green-700 dark:after:bg-amber-400 after:transition-[all_ease_in_out_300ms] after:mt-1 hover:after:w-full astro-6PA5N7LT">
  <a href="/search/" class="flex hover:text-black dark:hover:text-white p-1 astro-6PA5N7LT">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
    <span class="pl-2 pointer-events-none astro-6PA5N7LT">Search</span>
  </a>
</li><li class="after:block after:mx-auto after:h-[0.15em] after:bottom-0 after:w-0 after:bg-green-700 dark:after:bg-amber-400 after:transition-[all_ease_in_out_300ms] after:mt-1 hover:after:w-full astro-6PA5N7LT">
  <a href="/tags/" class="flex hover:text-black dark:hover:text-white p-1 astro-6PA5N7LT">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" /></svg>
    <span class="pl-2 pointer-events-none astro-6PA5N7LT">Tags</span>
  </a>
</li>
          <li class="astro-H24362AN">
            <!-- Theme, Light/Dark mode -->
            <label id="themeSetting" class="swap swap-rotate astro-H24362AN">
              <!-- this hidden checkbox controls the state -->
              <input type="checkbox" class="astro-H24362AN">
              <!-- sun icon -->
              <svg data-set-theme="cmyk" data-act-class="ACTIVECLASS" class="swap-on fill-current w-6 h-6 astro-H24362AN" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path d="M5.64,17l-.71.71a1,1,0,0,0,0,1.41,1,1,0,0,0,1.41,0l.71-.71A1,1,0,0,0,5.64,17ZM5,12a1,1,0,0,0-1-1H3a1,1,0,0,0,0,2H4A1,1,0,0,0,5,12Zm7-7a1,1,0,0,0,1-1V3a1,1,0,0,0-2,0V4A1,1,0,0,0,12,5ZM5.64,7.05a1,1,0,0,0,.7.29,1,1,0,0,0,.71-.29,1,1,0,0,0,0-1.41l-.71-.71A1,1,0,0,0,4.93,6.34Zm12,.29a1,1,0,0,0,.7-.29l.71-.71a1,1,0,1,0-1.41-1.41L17,5.64a1,1,0,0,0,0,1.41A1,1,0,0,0,17.66,7.34ZM21,11H20a1,1,0,0,0,0,2h1a1,1,0,0,0,0-2Zm-9,8a1,1,0,0,0-1,1v1a1,1,0,0,0,2,0V20A1,1,0,0,0,12,19ZM18.36,17A1,1,0,0,0,17,18.36l.71.71a1,1,0,0,0,1.41,0,1,1,0,0,0,0-1.41ZM12,6.5A5.5,5.5,0,1,0,17.5,12,5.51,5.51,0,0,0,12,6.5Zm0,9A3.5,3.5,0,1,1,15.5,12,3.5,3.5,0,0,1,12,15.5Z" class="astro-H24362AN"></path>
              </svg>
              <!-- moon icon -->
              <svg data-set-theme="night" data-act-class="ACTIVECLASS" class="swap-off fill-current w-6 h-6 astro-H24362AN" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path d="M21.64,13a1,1,0,0,0-1.05-.14,8.05,8.05,0,0,1-3.37.73A8.15,8.15,0,0,1,9.08,5.49a8.59,8.59,0,0,1,.25-2A1,1,0,0,0,8,2.36,10.14,10.14,0,1,0,22,14.05,1,1,0,0,0,21.64,13Zm-9.5,6.69A8.14,8.14,0,0,1,7.08,5.22v.27A10.15,10.15,0,0,0,17.22,15.63a9.79,9.79,0,0,0,2.1-.22A8.11,8.11,0,0,1,12.14,19.73Z" class="astro-H24362AN"></path>
              </svg>
            </label>
          </li>
        </ul>
      </nav>
    </header>
    <main id="main" class="container mx-auto astro-H24362AN">
      <h1 class="text-3xl md:text-5xl 2xl:text-6xl mb-[0.8em] font-extrabold mx-auto w-fit">MySQL锁</h1><div class="flex flex-wrap justify-evenly mb-9 mt-2">
    <div>
      <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
        <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
      </svg>
      <time datetime="2023-03-20T00:00:00.000Z">20 March 2023</time>
    </div>

    <div class="flex flex-wrap gap-2">
      <a class="p-[clamp(0.25rem,_0.25em,_0.5em)_0.5em] rounded-md text-stone-600 hover:text-stone-800 dark:text-stone-300 dark:hover:text-stone-100 astro-ZIEHN457" style="--tag-bg: #3CA5EA1a;--tag-prefix: #3CA5EA;" href="/tags/MySQL/">MySQL</a><a class="p-[clamp(0.25rem,_0.25em,_0.5em)_0.5em] rounded-md text-stone-600 hover:text-stone-800 dark:text-stone-300 dark:hover:text-stone-100 astro-ZIEHN457" style="--tag-bg: #3CA5EA1a;--tag-prefix: #3CA5EA;" href="/tags/Lock/">Lock</a><a class="p-[clamp(0.25rem,_0.25em,_0.5em)_0.5em] rounded-md text-stone-600 hover:text-stone-800 dark:text-stone-300 dark:hover:text-stone-100 astro-ZIEHN457" style="--tag-bg: #3CA5EA1a;--tag-prefix: #3CA5EA;" href="/tags/锁/">锁</a>
    </div>
  </div><div class="prose md:prose-lg 2xl:prose-xl px-4 mx-auto prose-pre:font-mono">
    <h2 id="数据库锁">数据库锁</h2>
<h3 id="1mysql都有什么锁死锁判定原理和具体场景死锁怎么解决">1.MySQL都有什么锁，死锁判定原理和具体场景，死锁怎么解决？</h3>
<h4 id="mysql有三种锁">MySQL有三种锁</h4>
<ul>
<li>表级锁：开销小，加锁快；不会出现死锁；锁粒度最大，发生锁冲突的概率最大，并发度最低</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁粒度最小，发生冲突的概率最低，并发度也最高</li>
<li>页级锁：开销和加锁的时间介于表级锁和行级锁；会出现死锁；锁粒度介于表锁和行锁之间，并发度一般</li>
</ul>
<h4 id="什么是死锁">什么是死锁？</h4>
<p>**死锁：**指两个或两个以上的进程在执行过程中，因争夺资源而造成的一项互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p>表级锁不会产生死锁，所以解决死锁主要还是针对于最常用的InnoDB。</p>
<p>**死锁的关键在于：**两个（或以上）Session加锁的顺序不一致。那么对应的解决死锁问题的关键就是，让不同的session加锁有次序。</p>
<h4 id="死锁的解决办法">死锁的解决办法</h4>
<ol>
<li>
<p>查出死锁的线程并kill掉</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #abb2bf">SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;</span></span></code></pre>
</li>
<li>
<p>设置锁的超时时间</p>
<p>InnoDB行锁的等待时间，单位秒，可在会话级别设置，RDS实例该参数的默认值为50秒</p>
<p>生产环境不推荐使用过大的 inoodb_lock_wait_timeout 参数值，该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间。如下：</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #abb2bf">set innodb_lock_wait_timeout = 1000;</span></span></code></pre>
</li>
<li>
<p>指定获取锁的顺序</p>
</li>
</ol>
<h4 id="2-有哪些锁select时怎么加排它锁">2. 有哪些锁，SELECT时怎么加排它锁？</h4>
<h5 id="加锁机制">加锁机制</h5>
<ul>
<li>
<p>悲观锁（Pessimistic Lock）：</p>
<p>特点：先获取锁，在进行业务操作。</p>
<p>即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功在进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供自持，即通过常用的 select … for update 操作来实现悲观锁。当数据库执行select … for update时会获取被select 中的数据行的行锁，因此其他并发执行的select … for update如果试图选择同一行则会发生排斥(需要等待行锁被释放)，因此达到锁的效果。select … for update 获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p>
<p><strong>补充</strong>：不同的数据库对 select … for update 的实现和支持都是有区别的。</p>
<ul>
<li>Oracle支持 select … for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL就没有 no wait这个选项。</li>
<li>MySQL还有个问题是 select … for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。</li>
</ul>
</li>
<li>
<p>乐观锁（Optimistic Lock）：</p>
<ol>
<li>
<p>乐观锁，也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据库后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。</p>
</li>
<li>
<p>乐观锁的特点是先进行业务操作，不得万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新的最后一步再去拿锁就好。乐观锁在数据上的实现完全是逻辑的，不需要数据库提供特殊的支持。</p>
</li>
<li>
<p>一般的做法是在需要锁的数据上增加一个版本号，或者时间戳。</p>
<p>实现方式举例如下：</p>
<p>乐观锁（给表加一个版本号字段），这个并不是乐观锁的定义，给表加版本号，是数据实现乐观锁的一种方式。</p>
<ol>
<li>seelct data as old_data, version as old_version from …;</li>
<li>根据获取的数据进行业务操作，得到new_data和new_version</li>
<li>update table set data = new_data, version = new_version where version = old_version</li>
</ol>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #abb2bf">if (updated row > 0 ) {</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">​    //乐观锁获取成功，操作完成</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">} else {</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">​    //乐观锁获取失败，回滚并重试</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">}</span></span></code></pre>
<p><strong>注意：</strong></p>
<ul>
<li>乐观锁在不发生取锁失败的情况下开销比乐观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能</li>
<li>乐观锁还适用于一些特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法使用的地方</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="总结"><strong>总结：</strong></h4>
<p>悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法。悲观锁和乐观锁大部分场景下差异不大，一些独特的场景下有一些差异，一般可以从如下几个方面来判断：</p>
<ul>
<li>响应速度：如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。</li>
<li>冲突频率：如果冲突频率非常公安，建议是采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。</li>
<li>重试代价：如果重试代价大，建议采用悲观锁。</li>
</ul>
<h4 id="扩展知识点">扩展知识点</h4>
<p>行级锁是MySQL中锁定粒度最细的一种锁，行级锁能大大减少数据库操作的冲突，行级锁分为共享锁和排它锁两种。</p>
<p><strong>共享锁(Share Lock)：</strong></p>
<p>共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取共享锁，不能加排它锁。获取共享锁的事务只能读取数据，不能修改数据。</p>
<p>用法：</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #C678DD">select</span><span style="color: #ABB2BF"> ... lock </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> share mode;</span></span></code></pre>
<p>在查询语句后面增加lock in share mode，MySQL就会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排它锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。</p>
<p><strong>排它锁(Exclusive Lock)：</strong></p>
<p>排它锁又称写锁、独占锁，如果事务T对数据A加上排它锁后，则其他事务不能再对A加任何类型的封锁。获取排它锁的事务既能读取数据，又能修改数据。</p>
<p>用法：</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #C678DD">select</span><span style="color: #ABB2BF"> ... for </span><span style="color: #C678DD">update</span><span style="color: #ABB2BF">;</span></span></code></pre>
<p>在查询语句后面加上 for update，MySQL就会对查询结果集中的每一行都加排它锁，当没有其他线程对查询结果集中的任何一行使用排它锁时，可以成功申请排它锁，否则会被阻塞。</p>
<p><strong>意向锁(Intention Lock)：</strong></p>
<p>意向锁是表级锁，其设计目的主要是为了在一个事务中揭示下一行将要被请求锁的类型。</p>
<p>InnoDB中的两个表锁：</p>
<ul>
<li>意向共享锁(IS)：表示事务准备给数据行加入共享锁，也就说一个数据行加共享锁前必须先取得该表的IS锁；</li>
<li>意向排它锁(IX)：类似上面，表示事务准备给数据行加入排它锁，说明事务在一个数据行加排它锁前必须先取得该表的IX锁；</li>
</ul>
<p>意向锁是InnoDB自动加的，不需要用户干预。</p>
<p>对于INSERT、UPDATE和DELETE，InnoDB会自动给涉及的数据加排它锁；对于一般的SELECT语句，InnoDB不会加任何锁，事务可以通过以下语句显式加共享锁或排它锁。</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #ABB2BF">## 共享锁</span></span>
<span class="line"><span style="color: #C678DD">select</span><span style="color: #ABB2BF"> ... lock </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> share mode;</span></span>
<span class="line"><span style="color: #ABB2BF">## 排它锁</span></span>
<span class="line"><span style="color: #C678DD">select</span><span style="color: #ABB2BF"> ... for </span><span style="color: #C678DD">update</span><span style="color: #ABB2BF">;</span></span></code></pre>
<h4 id="意向锁的引入解决了什么问题">意向锁的引入解决了什么问题？</h4>
<blockquote>
<p>假设，事务A获取了某一行的排它锁，尚未提交，此时事务B想要获取表锁时，必须要确认表的每一行都不存在排它锁，很明显效率会很低，引入意向锁之后，效率就会大为改善。</p>
</blockquote>
<ol>
<li>如果事务A获取了某一行的排它锁，实际此表存在两种锁，表中某一行的排它锁和表上的意向排它锁；</li>
<li>如果事务B试图在该表级别上加锁时，则受到上一个意向锁的阻塞，它在锁定该表前不必检查各个页或行锁，而只需要检查表上的意向锁。</li>
</ol>
<p><strong>宏观角度理解锁(图)</strong>
<img src="/mysql/MySQL-%E9%94%81.jpg" alt="mysql锁"></p>
<p>从锁粒度角度来讲，InnoDB允许行级锁与表级锁共存，而意向锁是表锁；从锁模式角度看，意向锁是一种独立类型，辅助解决记录锁效率不及的问题；从兼容性角度，意向锁包含了共享/排它两种。</p>
<p><strong>总结下意向锁的几个特征：</strong></p>
<ol>
<li>
<p>意向锁是表锁。做兼容性比照时，一定要分清是表锁还是行锁，如下图所示：</p>








































<table><thead><tr><th>兼容性</th><th>IS</th><th>IX</th><th>S</th><th>X</th></tr></thead><tbody><tr><td><strong>IS</strong></td><td>兼容</td><td>兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td><strong>IX</strong></td><td>兼容</td><td>兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td><strong>S</strong></td><td>兼容</td><td>不兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td><strong>X</strong></td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr></tbody></table>
<p>这里的排它（X）、共享（S）,说的是表锁。表级锁不会和行级锁做比对，这里特别容易混淆。意向锁不会与行级锁中的共享(S)、排它(X)互斥。</p>
</li>
<li>
<p>用户无法操作意向锁，意向锁是由InnoDB自己维护的。说白了，意向锁是帮助InnoDB提高效率的一种手段。</p>
</li>
</ol>
<p>举例：</p>
<p>表</p>

































<table><thead><tr><th>ID</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>ROADHOG</td></tr><tr><td>2</td><td>Reinhardt</td></tr><tr><td>3</td><td>Tracer</td></tr><tr><td>4</td><td>Genji</td></tr><tr><td>5</td><td>Hanzo</td></tr><tr><td>6</td><td>Mccree</td></tr></tbody></table>
<p>事务A先获取了某一行的排它锁，并未提交：</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #C678DD">select</span><span style="color: #ABB2BF"> * </span><span style="color: #C678DD">from</span><span style="color: #ABB2BF"> users </span><span style="color: #C678DD">where</span><span style="color: #ABB2BF"> id </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">6</span><span style="color: #ABB2BF"> for </span><span style="color: #C678DD">update</span><span style="color: #ABB2BF">;</span></span></code></pre>
<ol>
<li>事务A获取了users表上的<strong>意向排它锁</strong>。</li>
<li>事务A获取了id为6的数据行上的<strong>排它锁</strong>。</li>
</ol>
<p>之后事务B想要获取users表的共享锁：</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #ABB2BF">## 这是共享锁，表级锁</span></span>
<span class="line"><span style="color: #ABB2BF">lock tables users </span><span style="color: #C678DD">READ</span><span style="color: #ABB2BF">;</span></span>
<span class="line"><span style="color: #ABB2BF">## 这是排它锁，表级锁</span></span>
<span class="line"><span style="color: #ABB2BF">lock tables user WRITE;</span></span></code></pre>
<ol>
<li>事务B检测到事务A持有users表的<strong>意向排它锁</strong>。</li>
<li>事务B对users表的加锁请求被阻塞（排斥）。</li>
</ol>
<p>最后事务C也想获取users表中某一行的排它锁：</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #C678DD">select</span><span style="color: #ABB2BF"> * </span><span style="color: #C678DD">from</span><span style="color: #ABB2BF"> users </span><span style="color: #C678DD">where</span><span style="color: #ABB2BF"> id </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">5</span><span style="color: #ABB2BF"> for </span><span style="color: #C678DD">update</span><span style="color: #ABB2BF">;</span></span></code></pre>
<ol>
<li>事务C申请users表的<strong>意向排它锁</strong>。</li>
<li>事务C检测到事务A持有users表的<strong>意向排它锁</strong>。</li>
<li>因为意向锁之间并不互斥，所以事务C获取到了users表的意向排它锁。</li>
<li>因为id为5的数据行上不存在任何<strong>排它锁</strong>，最终事务C成功获取到了该数据行上的排它锁。</li>
</ol>
<p><strong>总结：</strong></p>
<ol>
<li>InnoDB支持多粒度锁，特定场景下，行级锁可以与表级锁共存。</li>
<li>意向锁之间互不排斥，但除了IS与S兼容外，意向锁会与 共享 / 排它锁互斥。</li>
<li>IX，IS是表级锁，不会和行级的X，S发生冲突，只会和表级的X、S发生冲突。</li>
<li>意向锁在保证并发行的前提下，实现了行锁和表锁共存且满足事务隔离性的要求。</li>
</ol>
<h4 id="3行锁的实现方式record-lock">3.行锁的实现方式（Record Lock）</h4>
<p>InnoDB行锁是通过给索引上的**<code>索引项</code>**（<em>通常是主键列或者唯一索引</em>）加锁来实现的，否则加的锁就会变成<code>Next-Key Lock</code>。同时查询语句必须为精准匹配（=），不能为 > 、 &#x3C; 、 like等，否则也会退化成<code>Next-Key Lock</code>。这一点MySQL与Oracle不同，候着是通过在数据块中相对应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只要通过索引条件检索数据，InnoDB才会使用行级锁，否则InnoDB将使用表级锁。</p>
<blockquote>
<p>实际应用中，需要特别注意InnoDB行锁这一特性，不然的话，可能会导致大量的锁冲突，从而影响性能。</p>
</blockquote>
<ol>
<li>在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。</li>
</ol>
<p>在如下所示的例子中，开始tab_no_index表没有索引：</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #C678DD">create</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">table</span><span style="color: #ABB2BF"> tab_no_index(id </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">,</span><span style="color: #C678DD">name</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">varchar</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">)) engine</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">innodb;  </span></span>
<span class="line"><span style="color: #ABB2BF">## Query OK, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">rows</span><span style="color: #ABB2BF"> affected (</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">.</span><span style="color: #D19A66">15</span><span style="color: #ABB2BF"> sec)  </span></span>
<span class="line"><span style="color: #C678DD">insert</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">into</span><span style="color: #ABB2BF"> tab_no_index </span><span style="color: #C678DD">values</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">,</span><span style="color: #98C379">'1'</span><span style="color: #ABB2BF">),(</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">,</span><span style="color: #98C379">'2'</span><span style="color: #ABB2BF">),(</span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">,</span><span style="color: #98C379">'3'</span><span style="color: #ABB2BF">),(</span><span style="color: #D19A66">4</span><span style="color: #ABB2BF">,</span><span style="color: #98C379">'4'</span><span style="color: #ABB2BF">);  </span></span>
<span class="line"><span style="color: #ABB2BF">## Query OK, </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">rows</span><span style="color: #ABB2BF"> affected (</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">.</span><span style="color: #D19A66">00</span><span style="color: #ABB2BF"> sec)  </span></span>
<span class="line"><span style="color: #ABB2BF">## Records: </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF">  Duplicates: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">  Warnings: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">  </span></span></code></pre>





















<table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td>mysql> set autocommit=0;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql> select * from tab_no_index where id = 1 ;<br>+------+------+<br>| id  | name |<br>+------+------+<br>| 1  | 1  |<br>+------+------+<br>1 row in set (0.00 sec)</td><td>mysql> set autocommit=0;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql> select * from tab_no_index where id = 2 ;<br>+------+------+<br>| id  | name |<br>+------+------+<br>| 2  | 2  |<br>+------+------+<br>1 row in set (0.00 sec)</td></tr><tr><td>mysql> select * from tab_no_index where id = 1 for update;<br>+------+------+<br>| id  | name |<br>+------+------+<br>| 1  | 1  |<br>+------+------+<br>1 row in set (0.00 sec)</td><td></td></tr><tr><td></td><td>mysql> select * from tab_no_index where id = 2 for update;<br>等待</td></tr></tbody></table>
<p>在如上表所示的例子中，看起来session_1只给一行加了排他锁，但session_2在请求其他行的排他锁时，却出现了锁等待！原因就是在没有索引的情况下，InnoDB只能使用表锁。当我们给其增加一个索引后，InnoDB就只锁定了符合条件的行，如下表所示。</p>
<p>创建tab_with_index表，id字段有普通索引：</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #C678DD">create</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">table</span><span style="color: #ABB2BF"> tab_with_index(id </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">,</span><span style="color: #C678DD">name</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">varchar</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">)) engine</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">innodb;  </span></span>
<span class="line"><span style="color: #ABB2BF">## Query OK, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">rows</span><span style="color: #ABB2BF"> affected (</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">.</span><span style="color: #D19A66">15</span><span style="color: #ABB2BF"> sec)  </span></span>
<span class="line"><span style="color: #C678DD">alter</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">table</span><span style="color: #ABB2BF"> tab_with_index </span><span style="color: #C678DD">add</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">index</span><span style="color: #ABB2BF"> id(id);  </span></span>
<span class="line"><span style="color: #ABB2BF">## Query OK, </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">rows</span><span style="color: #ABB2BF"> affected (</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">.</span><span style="color: #D19A66">24</span><span style="color: #ABB2BF"> sec)  </span></span>
<span class="line"><span style="color: #ABB2BF">## Records: </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF">  Duplicates: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">  Warnings: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">  </span></span></code></pre>
<p>InnoDB存储引擎的表在使用索引时使用行锁例子</p>





















<table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td>mysql> set autocommit=0;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql> select * from tab_with_index where id = 1 ;<br>+------+------+<br>| id  | name |<br>+------+------+<br>| 1  | 1  |<br>+------+------+<br>1 row in set (0.00 sec)</td><td>mysql> set autocommit=0;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql> select * from tab_with_index where id = 2 ;<br>+------+------+<br>| id  | name |<br>+------+------+<br>| 2  | 2  |<br>+------+------+<br>1 row in set (0.00 sec)</td></tr><tr><td>mysql> select * from tab_with_index where id = 1 for update;<br>+------+------+<br>| id  | name |<br>+------+------+<br>| 1  | 1  |<br>+------+------+<br>1 row in set (0.00 sec)</td><td></td></tr><tr><td></td><td>mysql> select * from tab_with_index where id = 2 for update;<br>+------+------+<br>| id  | name |<br>+------+------+<br>| 2  | 2  |<br>+------+------+<br>1 row in set (0.00 sec)</td></tr></tbody></table>
<ol start="2">
<li>由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候要注意这一点。</li>
</ol>
<p>在如下表所示的例子中，表tab_with_index的id字段有索引，name字段没有索引：</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #C678DD">alter</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">table</span><span style="color: #ABB2BF"> tab_with_index </span><span style="color: #C678DD">drop</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">index</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">name</span><span style="color: #ABB2BF">;  </span></span>
<span class="line"><span style="color: #ABB2BF">## Query OK, </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">rows</span><span style="color: #ABB2BF"> affected (</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">.</span><span style="color: #D19A66">22</span><span style="color: #ABB2BF"> sec)  </span></span>
<span class="line"><span style="color: #ABB2BF">## Records: </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF">  Duplicates: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">  Warnings: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">  </span></span>
<span class="line"><span style="color: #C678DD">insert</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">into</span><span style="color: #ABB2BF"> tab_with_index  </span><span style="color: #C678DD">values</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">,</span><span style="color: #98C379">'4'</span><span style="color: #ABB2BF">);  </span></span>
<span class="line"><span style="color: #ABB2BF">## Query OK, </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">row</span><span style="color: #ABB2BF"> affected (</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">.</span><span style="color: #D19A66">00</span><span style="color: #ABB2BF"> sec)  </span></span>
<span class="line"><span style="color: #C678DD">select</span><span style="color: #ABB2BF"> * </span><span style="color: #C678DD">from</span><span style="color: #ABB2BF"> tab_with_index </span><span style="color: #C678DD">where</span><span style="color: #ABB2BF"> id </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;  </span></span>
<span class="line"><span style="color: #ABB2BF">+</span><span style="color: #7F848E; font-style: italic">------+------+  </span></span>
<span class="line"><span style="color: #ABB2BF">| id   | </span><span style="color: #C678DD">name</span><span style="color: #ABB2BF"> |  </span></span>
<span class="line"><span style="color: #ABB2BF">+</span><span style="color: #7F848E; font-style: italic">------+------+  </span></span>
<span class="line"><span style="color: #ABB2BF">| </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">    | </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">    |  </span></span>
<span class="line"><span style="color: #ABB2BF">| </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">    | </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF">    |  </span></span>
<span class="line"><span style="color: #ABB2BF">+</span><span style="color: #7F848E; font-style: italic">------+------+  </span></span>
<span class="line"><span style="color: #D19A66">2</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">rows</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">set</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">.</span><span style="color: #D19A66">00</span><span style="color: #ABB2BF"> sec)  </span></span></code></pre>
<p>InnoDB存储引擎使用相同索引键的阻塞例子</p>





















<table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td>mysql> set autocommit=0;<br>Query OK, 0 rows affected (0.00 sec)</td><td>mysql> set autocommit=0;<br>Query OK, 0 rows affected (0.00 sec)</td></tr><tr><td>mysql> select * from tab_with_index where id = 1 and name = ‘1’ for update;<br>+------+------+<br>| id  | name |<br>+------+------+<br>| 1  | 1  |<br>+------+------+<br>1 row in set (0.00 sec)</td><td></td></tr><tr><td></td><td>虽然session_2访问的是和session_1不同的记录，但是因为使用了相同的索引,所以需要等待锁：<br>mysql> select * from tab_with_index where id = 1 and name = ‘4’ for update;<br>等待</td></tr></tbody></table>
<ol start="3">
<li>当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。</li>
</ol>
<p>在如下表所示的例子中，表tab_with_index的id字段有主键索引，name字段有普通索引：</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #C678DD">alter</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">table</span><span style="color: #ABB2BF"> tab_with_index </span><span style="color: #C678DD">add</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">index</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">name</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">name</span><span style="color: #ABB2BF">);  </span></span>
<span class="line"><span style="color: #ABB2BF">## Query OK, </span><span style="color: #D19A66">5</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">rows</span><span style="color: #ABB2BF"> affected (</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">.</span><span style="color: #D19A66">23</span><span style="color: #ABB2BF"> sec)  </span></span>
<span class="line"><span style="color: #ABB2BF">## Records: </span><span style="color: #D19A66">5</span><span style="color: #ABB2BF">  Duplicates: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">  Warnings: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">  </span></span></code></pre>
<p>InnoDB存储引擎的表使用不同索引的阻塞例子</p>

























<table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td>mysql> set autocommit=0;<br>Query OK, 0 rows affected (0.00 sec)</td><td>mysql> set autocommit=0;<br>Query OK, 0 rows affected (0.00 sec)</td></tr><tr><td>mysql> select * from tab_with_index where id = 1 for update;<br>+------+------+<br>| id  | name |<br>+------+------+<br>| 1  | 1  |<br>| 1  | 4  |<br>+------+------+<br>2 rows in set (0.00 sec)</td><td></td></tr><tr><td></td><td>Session_2使用name的索引访问记录，因为记录没有被索引，所以可以获得锁：<br>mysql> select * from tab_with_index where name = ‘2’ for update;<br>+------+------+<br>| id  | name |<br>+------+------+<br>| 2  | 2  |<br>+------+------+<br>1 row in set (0.00 sec)</td></tr><tr><td></td><td>由于访问的记录已经被session_1锁定，所以等待获得锁。<br>mysql> select * from tab_with_index where name = ‘4’ for update;</td></tr></tbody></table>
<ol start="4">
<li>即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，<strong>如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁</strong>。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</li>
</ol>
<p>在下面的例子中，检索值的数据类型与索引字段不同，虽然MySQL能够进行数据类型转换，但却不会使用索引，从而导致InnoDB使用表锁。通过用explain检查两条SQL的执行计划，我们可以清楚地看到了这一点。</p>
<p>例子中tab_with_index表的name字段有索引，但是name字段是varchar类型的，如果where条件中不是和varchar类型进行比较，则会对name进行类型转换，而执行的全表扫描。</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #C678DD">alter</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">table</span><span style="color: #ABB2BF"> tab_no_index </span><span style="color: #C678DD">add</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">index</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">name</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">name</span><span style="color: #ABB2BF">);  </span></span>
<span class="line"><span style="color: #ABB2BF">## Query OK, </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">rows</span><span style="color: #ABB2BF"> affected (</span><span style="color: #D19A66">8</span><span style="color: #ABB2BF">.</span><span style="color: #D19A66">06</span><span style="color: #ABB2BF"> sec)  </span></span>
<span class="line"><span style="color: #ABB2BF">## Records: </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF">  Duplicates: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">  Warnings: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">  </span></span>
<span class="line"><span style="color: #ABB2BF">explain </span><span style="color: #C678DD">select</span><span style="color: #ABB2BF"> * </span><span style="color: #C678DD">from</span><span style="color: #ABB2BF"> tab_with_index </span><span style="color: #C678DD">where</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">name</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> \G  </span></span>
<span class="line"><span style="color: #ABB2BF">*************************** </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">. </span><span style="color: #C678DD">row</span><span style="color: #ABB2BF"> ***************************  </span></span>
<span class="line"><span style="color: #ABB2BF">           id: </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">  </span></span>
<span class="line"><span style="color: #ABB2BF">  select_type: </span><span style="color: #C678DD">SIMPLE</span><span style="color: #ABB2BF">  </span></span>
<span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">table</span><span style="color: #ABB2BF">: tab_with_index  </span></span>
<span class="line"><span style="color: #ABB2BF">         </span><span style="color: #C678DD">type</span><span style="color: #ABB2BF">: ALL  </span></span>
<span class="line"><span style="color: #ABB2BF">possible_keys: </span><span style="color: #C678DD">name</span><span style="color: #ABB2BF">  </span></span>
<span class="line"><span style="color: #ABB2BF">          </span><span style="color: #C678DD">key</span><span style="color: #ABB2BF">: </span><span style="color: #C678DD">NULL</span><span style="color: #ABB2BF">  </span></span>
<span class="line"><span style="color: #ABB2BF">      key_len: </span><span style="color: #C678DD">NULL</span><span style="color: #ABB2BF">  </span></span>
<span class="line"><span style="color: #ABB2BF">          ref: </span><span style="color: #C678DD">NULL</span><span style="color: #ABB2BF">  </span></span>
<span class="line"><span style="color: #ABB2BF">         </span><span style="color: #C678DD">rows</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF">  </span></span>
<span class="line"><span style="color: #ABB2BF">        Extra: </span><span style="color: #C678DD">Using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">where</span><span style="color: #ABB2BF">  </span></span>
<span class="line"><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">row</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">set</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">.</span><span style="color: #D19A66">00</span><span style="color: #ABB2BF"> sec)  </span></span>
<span class="line"><span style="color: #ABB2BF">mysql</span><span style="color: #56B6C2">></span><span style="color: #ABB2BF"> explain </span><span style="color: #C678DD">select</span><span style="color: #ABB2BF"> * </span><span style="color: #C678DD">from</span><span style="color: #ABB2BF"> tab_with_index </span><span style="color: #C678DD">where</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">name</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'1'</span><span style="color: #ABB2BF"> \G  </span></span>
<span class="line"><span style="color: #ABB2BF">*************************** </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">. </span><span style="color: #C678DD">row</span><span style="color: #ABB2BF"> ***************************  </span></span>
<span class="line"><span style="color: #ABB2BF">           id: </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">  </span></span>
<span class="line"><span style="color: #ABB2BF">  select_type: </span><span style="color: #C678DD">SIMPLE</span><span style="color: #ABB2BF">  </span></span>
<span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">table</span><span style="color: #ABB2BF">: tab_with_index  </span></span>
<span class="line"><span style="color: #ABB2BF">         </span><span style="color: #C678DD">type</span><span style="color: #ABB2BF">: ref  </span></span>
<span class="line"><span style="color: #ABB2BF">possible_keys: </span><span style="color: #C678DD">name</span><span style="color: #ABB2BF">  </span></span>
<span class="line"><span style="color: #ABB2BF">          </span><span style="color: #C678DD">key</span><span style="color: #ABB2BF">: </span><span style="color: #C678DD">name</span><span style="color: #ABB2BF">  </span></span>
<span class="line"><span style="color: #ABB2BF">      key_len: </span><span style="color: #D19A66">23</span><span style="color: #ABB2BF">  </span></span>
<span class="line"><span style="color: #ABB2BF">          ref: const  </span></span>
<span class="line"><span style="color: #ABB2BF">         </span><span style="color: #C678DD">rows</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">  </span></span>
<span class="line"><span style="color: #ABB2BF">        Extra: </span><span style="color: #C678DD">Using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">where</span><span style="color: #ABB2BF">  </span></span>
<span class="line"><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">row</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">set</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">.</span><span style="color: #D19A66">00</span><span style="color: #ABB2BF"> sec)  </span></span></code></pre>
<h4 id="4-间隙锁gap-lock与next--key锁">4. 间隙锁(Gap Lock)与Next -Key锁</h4>
<p><strong>间隙锁</strong>基于<code>非唯一索引</code>，它<code>锁定一段范围内的索引记录</code>。<strong>间隙锁</strong>基于下面将会提到的<code>Next-Key Locking</code> 算法，请务必牢记：<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据</strong>。</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #C678DD">SELECT</span><span style="color: #ABB2BF"> * </span><span style="color: #C678DD">FROM</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">table</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">WHERE</span><span style="color: #ABB2BF"> id BETWEN </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">AND</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #ABB2BF"> FOR </span><span style="color: #C678DD">UPDATE</span><span style="color: #ABB2BF">;</span></span></code></pre>
<p>即所有在<code>（1，10）</code>区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。
除了手动加锁外，在执行完某些 SQL 后，InnoDB 也会自动加<strong>间隙锁</strong>，这个我们在下面会提到。</p>
<p><strong>临键锁（Next-Key Locks）</strong>
Next-Key 可以理解为一种特殊的<strong>间隙锁</strong>，也可以理解为一种特殊的<strong>算法</strong>。通过<strong>临建锁</strong>可以解决<code>幻读</code>的问题。 每个数据行上的<code>非唯一索引列</code>上都会存在一把<strong>临键锁</strong>，当某个事务持有该数据行的<strong>临键锁</strong>时，会锁住一段<strong>左开右闭区间</strong>的数据。需要强调的一点是，<code>InnoDB</code> 中<code>行级锁</code>是基于索引实现的，<strong>临键锁</strong>只与<code>非唯一索引列</code>有关，在<code>唯一索引列</code>（包括<code>主键列</code>）上不存在<strong>临键锁</strong>。</p>
<p>假设有如下表：
<strong>MySql</strong>，<strong>InnoDB</strong>，<strong>Repeatable-Read</strong>：table(id PK, age KEY, name)</p>






























<table><thead><tr><th>id</th><th>age</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>10</td><td>Lee</td></tr><tr><td>3</td><td>24</td><td>sower</td></tr><tr><td>5</td><td>32</td><td>cp</td></tr><tr><td>7</td><td>45</td><td>fansw</td></tr></tbody></table>
<p>该表中 <code>age</code> 列潜在的<code>临键锁</code>有：
(-∞, 10],
(10, 24],
(24, 32],
(32, 45],
(45, +∞],
在<code>事务 A</code> 中执行如下命令：</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #7F848E; font-style: italic">-- 根据非唯一索引列 UPDATE 某条记录 </span></span>
<span class="line"><span style="color: #C678DD">UPDATE</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">table</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">SET</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">name</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> Vladimir </span><span style="color: #C678DD">WHERE</span><span style="color: #ABB2BF"> age </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">24</span><span style="color: #ABB2BF">; </span></span>
<span class="line"><span style="color: #7F848E; font-style: italic">-- 或根据非唯一索引列 锁住某条记录 </span></span>
<span class="line"><span style="color: #C678DD">SELECT</span><span style="color: #ABB2BF"> * </span><span style="color: #C678DD">FROM</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">table</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">WHERE</span><span style="color: #ABB2BF"> age </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">24</span><span style="color: #ABB2BF"> FOR </span><span style="color: #C678DD">UPDATE</span><span style="color: #ABB2BF">; </span></span></code></pre>
<p>不管执行了上述 SQL 中的哪一句，之后如果在<code>事务 B</code> 中执行以下命令，则该命令会被阻塞：</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #C678DD">INSERT</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">INTO</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">table</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">VALUES</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">100</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">26</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'Ezreal'</span><span style="color: #ABB2BF">); </span></span></code></pre>
<p>很明显，<code>事务 A</code> 在对 <code>age</code> 为 24 的列进行 UPDATE 操作的同时，也获取了 <code>(24, 32]</code> 这个区间内的临键锁。
不仅如此，在执行以下 SQL 时，也会陷入阻塞等待：</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #C678DD">INSERT</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">INTO</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">table</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">VALUES</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">100</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">30</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'Ezreal'</span><span style="color: #ABB2BF">); </span></span></code></pre>
<p>那最终我们就可以得知，在根据<code>非唯一索引</code> 对记录行进行 <code>UPDATE \ FOR UPDATE \ LOCK IN SHARE MODE</code> 操作时，InnoDB 会获取该记录行的 <code>临键锁</code> ，并同时获取该记录行下一个区间的<code>间隙锁</code>。
即<code>事务 A</code>在执行了上述的 SQL 后，最终被锁住的记录区间为 <code>(10, 32)</code>。
<strong>总结:</strong></p>
<ol>
<li><strong>InnoDB</strong> 中的<code>行锁</code>的实现依赖于<code>索引</code>，一旦某个加锁操作没有使用到索引，那么该锁就会退化为<code>表锁</code>。</li>
<li><strong>记录锁</strong>存在于包括<code>主键索引</code>在内的<code>唯一索引</code>中，锁定单条索引记录。</li>
<li><strong>间隙锁</strong>存在于<code>非唯一索引</code>中，锁定<code>开区间</code>范围内的一段间隔，它是基于<strong>临键锁</strong>实现的。</li>
<li><strong>临键锁</strong>存在于<code>非唯一索引</code>中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的<strong>间隙锁</strong>，锁定一段<code>左开右闭</code>的索引区间。</li>
</ol>
<hr>
<p>另外一个网站的举例：</p>
<p>举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #C678DD">Select</span><span style="color: #ABB2BF"> * </span><span style="color: #C678DD">from</span><span style="color: #ABB2BF">  emp </span><span style="color: #C678DD">where</span><span style="color: #ABB2BF"> empid </span><span style="color: #56B6C2">></span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">100</span><span style="color: #ABB2BF"> for </span><span style="color: #C678DD">update</span><span style="color: #ABB2BF">;</span></span></code></pre>
<p>是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p>
<p>InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其它事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。</p>
<p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>
<p>还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！</p>
<p>在如下表所示的例子中，假如emp表中只有101条记录，其empid的值分别是1,2,…,100,101。</p>
<p>​                                  <em>InnoDB存储引擎的间隙锁阻塞例子</em></p>





























<table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td>mysql> select @@tx_isolation;<br>+-----------------+<br>| @@tx_isolation |<br>+-----------------+<br>| REPEATABLE-READ |<br>+-----------------+<br>1 row in set (0.00 sec)<br>mysql> set autocommit = 0;<br>Query OK, 0 rows affected (0.00 sec)</td><td>mysql> select @@tx_isolation;<br>+-----------------+<br>| @@tx_isolation |<br>+-----------------+<br>| REPEATABLE-READ |<br>+-----------------+<br>1 row in set (0.00 sec)<br>mysql> set autocommit = 0;<br>Query OK, 0 rows affected (0.00 sec)</td></tr><tr><td>当前session对不存在的记录加for update的锁：<br>mysql> select * from emp where empid = 102 for update;<br>Empty set (0.00 sec)</td><td></td></tr><tr><td></td><td>这时，如果其他session插入empid为102的记录（注意：这条记录并不存在），也会出现锁等待：<br>mysql>insert into emp(empid,…) values(102,…);<br>阻塞等待</td></tr><tr><td>Session_1 执行rollback：mysql> rollback;<br>Query OK, 0 rows affected (13.04 sec)</td><td></td></tr><tr><td></td><td>由于其他session_1回退后释放了Next-Key锁，当前session可以获得锁并成功插入记录：<br>mysql>insert into emp(empid,…) values(102,…);<br>Query OK, 1 row affected (13.35 sec)</td></tr></tbody></table>
<h4 id="5插入意向锁">5.插入意向锁</h4>
<blockquote>
<p>前言：</p>
<p>在讲解之前，先来思考一个问题——假设有用户表结构如下：
<strong>MySql</strong>，<strong>InnoDB</strong>，<strong>Repeatable-Read</strong>：users(id PK, name, age KEY)</p>
</blockquote>

























<table><thead><tr><th>id</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>Mike</td><td>10</td></tr><tr><td>2</td><td>Jone</td><td>20</td></tr><tr><td>3</td><td>Tony</td><td>30</td></tr></tbody></table>
<p>首先事务A插入了一行数据，并且没有Commit</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #C678DD">INSERT</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">INTO</span><span style="color: #ABB2BF"> users </span><span style="color: #C678DD">SELECT</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'Bill'</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">15</span><span style="color: #ABB2BF">;</span></span></code></pre>
<p>随后事务B试图插入一行数据</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #C678DD">INSERT</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">INTO</span><span style="color: #ABB2BF"> users </span><span style="color: #C678DD">SELECT</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">5</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'Louis'</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">16</span><span style="color: #ABB2BF">;</span></span></code></pre>
<p>请问：</p>
<ol>
<li>使用了什么锁？</li>
<li>事务B是否会被事务A阻塞？</li>
</ol>
<p>插入意向锁（Insert Intention Locks）</p>
<p><code>插入意向锁</code>是在插入一条记录行前，由 <strong>INSERT</strong> 操作产生的一种<code>间隙锁</code>。该锁用以表示插入<strong>意向</strong>，当多个事务在<strong>同一区间</strong>（gap）插入<strong>位置不同</strong>的多条数据时，事务之间<strong>不需要互相等待</strong>。假设存在两条值分别为 4 和 7 的记录，两个不同的事务分别试图插入值为 5 和 6 的两条记录，每个事务在获取插入行上独占的（排他）锁前，都会获取（4，7）之间的<code>间隙锁</code>，但是因为数据行之间并不冲突，所以两个事务之间并<strong>不会产生冲突</strong>（阻塞等待）。</p>
<p>总结来说，<code>插入意向锁</code>的特性可以分成两部分：</p>
<ol>
<li><code>插入意向锁</code>是一种特殊的<code>间隙锁</code> —— <code>间隙锁</code>可以锁定<strong>开区间</strong>内的部分记录。</li>
<li><code>插入意向锁</code>之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身（<code>主键</code>、<code>唯一索引</code>）不冲突，那么事务之间就不会出现<strong>冲突等待</strong>。</li>
</ol>
<p>需要强调的是，虽然<code>插入意向锁</code>中含有<code>意向锁</code>三个字，但是它并不属于<code>意向锁</code>而属于<code>间隙锁</code>，因为<code>意向锁</code>是<strong>表锁</strong>而<code>插入意向锁</code>是<strong>行锁</strong>。
现在我们可以回答开头的问题了：</p>
<ol>
<li>使用<code>插入意向锁</code>与<code>记录锁</code>。</li>
<li><code>事务 A</code> 不会阻塞<code>事务 B</code>。</li>
</ol>
<p>为什么不用间隙锁
如果只是使用普通的<code>间隙锁</code>会怎么样呢？还是使用我们文章开头的数据表为例：</p>
<p>首先<code>事务 A</code> 插入了一行数据，并且没有 <code>commit</code>：</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #C678DD">INSERT</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">INTO</span><span style="color: #ABB2BF"> users </span><span style="color: #C678DD">SELECT</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'Bill'</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">15</span><span style="color: #ABB2BF">; </span></span></code></pre>
<p>此时 <code>users</code> 表中存在<strong>三把锁</strong>：</p>
<ol>
<li>id 为 4 的记录行的<code>记录锁</code>。</li>
<li>age 区间在（10，15）的<code>间隙锁</code>。</li>
<li>age 区间在（15，20）的<code>间隙锁</code>。</li>
</ol>
<p>最终，<code>事务 A</code> 插入了该行数据，并锁住了（10，20）这个区间。
随后<code>事务 B</code> 试图插入一行数据：</p>
<pre is:raw="" class="astro-code" style="background-color: #282c34; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><code><span class="line"><span style="color: #C678DD">INSERT</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">INTO</span><span style="color: #ABB2BF"> users </span><span style="color: #C678DD">SELECT</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">5</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'Louis'</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">16</span><span style="color: #ABB2BF">; </span></span></code></pre>
<p>因为 16 位于（15，20）区间内，而该区间内又存在一把<code>间隙锁</code>，所以<code>事务 B</code> 别说想申请自己的<code>间隙锁</code>了，它甚至不能获取该行的<code>记录锁</code>，自然只能乖乖的等待 <code>事务 A</code> 结束，才能执行插入操作。
很明显，这样做事务之间将会频发陷入<strong>阻塞等待</strong>，<strong>插入的并发性</strong>非常之差。这时如果我们再去回想我们刚刚讲过的<code>插入意向锁</code>，就不难发现它是如何优雅的解决了<strong>并发插入</strong>的问题。</p>
<p><strong>总结：</strong></p>
<ol>
<li><strong>MySql InnoDB</strong> 在 <code>Repeatable-Read</code> 的事务隔离级别下，使用<code>插入意向锁</code>来控制和解决并发插入。</li>
<li><code>插入意向锁</code>是一种特殊的<code>间隙锁</code>。</li>
<li><code>插入意向锁</code>在锁定区间相同但记录行本身不冲突的情况下互不排斥。</li>
</ol>
  </div>
    </main>

    <svg xmlns="http://www.w3.org/2000/svg" id="scrollButton" viewBox="0 0 512 512" class="w-10 h-10 fill-primary fixed bottom-5 right-5 animate-[jump_1500ms_infinite] cursor-pointer bg-base-100 rounded-full astro-H24362AN" style="display: none">
      <path d="M256 0C114.6 0 0 114.6 0 256c0 141.4 114.6 256 256 256s256-114.6 256-256C512 114.6 397.4 0 256 0zM382.6 254.6c-12.5 12.5-32.75 12.5-45.25 0L288 205.3V384c0 17.69-14.33 32-32 32s-32-14.31-32-32V205.3L174.6 254.6c-12.5 12.5-32.75 12.5-45.25 0s-12.5-32.75 0-45.25l103.1-103.1C241.3 97.4 251.1 96 256 96c4.881 0 14.65 1.391 22.65 9.398l103.1 103.1C395.1 221.9 395.1 242.1 382.6 254.6z" class="astro-H24362AN"></path>
    </svg>

    <footer class="border-t px-4 py-6 mt-6 astro-H24362AN">
      <p class="text-center text-sm astro-H24362AN">
        &copy; 2023
        gwalnut
      </p>
      <p class="text-center text-xs astro-H24362AN">
        Built with <a class="text-cyan-600 hover:text-black dark:hover:text-white astro-H24362AN" href="https://astro.build" target="_blank" rel="noreferrer noopener">Astro v1.1.1
        </a>
      </p>
    </footer>
  </body>
</html>



